[TOC]
# 拉链表是什么？

## 什么是拉链表
> 拉链表是针对数据仓库设计中表存储数据的方式而定义的，顾名思义，所谓拉链，就是记录历史。记录一个事物从开始，一直到当前状态的所有变化的信息。

我们先看一个示例，这就是一张拉链表, 最新一天（即 2017-01-03 ）的数据：

| 注册日期   | 用户编号 | 手机号码 | t_start_date | t_end_date |
| :--------- | :------- | :------- | :----------- | :--------- |
| 2017-01-01 | 001      | 111111   | 2017-01-01   | 9999-12-31 |
| 2017-01-01 | 002      | 222222   | 2017-01-01   | 2017-01-01 |
| 2017-01-01 | 002      | 233333   | 2017-01-02   | 9999-12-31 |
| 2017-01-01 | 003      | 333333   | 2017-01-01   | 9999-12-31 |
| 2017-01-01 | 004      | 444444   | 2017-01-01   | 2017-01-01 |
| 2017-01-01 | 004      | 432432   | 2017-01-02   | 2017-01-02 |
| 2017-01-01 | 004      | 432432   | 2017-01-03   | 9999-12-31 |
| 2017-01-02 | 005      | 555555   | 2017-01-02   | 2017-01-02 |
| 2017-01-02 | 005      | 115115   | 2017-01-03   | 9999-12-31 |
| 2017-01-03 | 006      | 666666   | 2017-01-03   | 9999-12-31 |
`table1`(命名为 table 1 后续提到table 1 就代表这张表)

存储的是用户的最基本信息以及每条记录的生命周期-- 体现在俩个字段`t_start_date` 和 `t_end_date`。我们可以使用这张表拿到当天的最新数据以及之前的历史数据。

| 注册日期   | 用户编号 | 手机号码 | t_start_date | t_end_date |
| :--------- | :------- | :------- | :----------- | :--------- |
| 2017-01-02 | 005      | 555555   | 2017-01-02   | 2017-01-02 |
| 2017-01-02 | 005      | 115115   | 2017-01-03   | 9999-12-31 |

观察这俩条数据发现, 日期数据不相交

**需求**
**拿出最新数据 ** 可以使用`t_end_date` 筛选值为 `9999-12-31`就是最新数据
**拿出历史数据** 假如需要选取出 `2017-01-02`日的数据, 可以使用 `t_start_date <= 2017-01-02 and t_end_date>=2017-01-02` 筛选出目标数据

> t_start_date  --------------  2017-01-02 -------------- t_end_date


## 如何解决缓慢变化维
### 缓慢变化维场景
在数据仓库的数据模型设计过程中，经常会遇到下面这种表的设计：

* 有一些表的数据量很大，比如一张用户表，大约 10 亿条记录，50 个字段，这种表，即使使用 Orc 压缩，单张表的存储也会超过 100G，在 Hdfs 使用双备份或者三备份的话就更大一些。
* 表中的部分字段会被 Update 更新操作，如用户联系方式，产品的描述信息，订单的状态等等。
* 需要查看某一个时间点或者时间段的历史快照信息，比如，查看某一个订单在历史某一个时间点的状态。
* 表中的记录变化的比例和频率不是很大，比如，总共有 10 亿的用户，每天新增和发生变化的有 200 万左右，**变化的比例占的很小**。

### 各种解决方案
方案一：只留最新的一份，比如我们每天用 Sqoop 抽取最新的一份全量数据到 Hive 中。
方案二：每天保留一份全量的切片数据。
方案三：使用拉链表。

### 各种方案对比
从`存储空间`和`是否保存历史数据`俩个方面讨论
#### 方案一
这种方案就不用多说了，实现起来很简单，每天 Drop 掉前一天的数据，重新抽一份最新的。
**优点**很明显，节省空间，一些普通的使用也很方便，不用在选择表的时候加一个时间分区什么的。
**缺点**同样明显，没有历史数据，先翻翻旧账只能通过其它方式，比如从流水表里面抽。

#### 方案二
每天一份全量的切片是一种比较稳妥的方案，而且历史数据也在。

**优点**有历史数据
**缺点**就是存储空间占用量**太大太大**了，如果对这边表每天都保留一份全量，那么**每次全量中会保存很多不变**的信息，对存储是极大的浪费。

当然我们也可以做一些取舍，比如只保留近一个月的数据。但是，需求是无耻的，数据的生命周期不是我们能完全左右的，你会发现，存储周期可能会从 30 天变为 90 天，然后再从 90 天变为 1 年，然后需要永久保存。

#### 拉链表
拉链表在使用上基本兼顾了我们的需求。

首先它在**空间**上做了一个取舍，虽说不像方案一那样占用量那么小，但是它每日的增量可能只有方案二的千分之一甚至是万分之一。

其实它能满足方案二所能满足的需求，既能获取最新的数据，也能添加筛选条件也获取**历史的数据**。所以在一些场景下，拉链表是能解决很多问题的。

## table1的数据源表随时间变化
下面我们来举个栗子详细聊一下拉链表。以用户资料表为例，我们先看一下在关系型数据库里的 User 表中信息变化。

在 2017-01-01 这一天表中的数据是：
| 注册日期	 | 用户编号 | 	手机号码 | 
| :--------- | :------- | :------- |
| 2017-01-01 | 	001 | 	111111 | 
|2017-01-01	|002	|222222|
|2017-01-01|	003|	333333|
|2017-01-01	|004|	444444|

在 2017-01-02 这一天表中的数据是， 用户 002 和 004 资料进行了修改，005 是新增用户：
|注册日期|	用户编号|	手机号码|	备注|
| :--------- | :------- | :------- |  :------- | 
|2017-01-01|	001|	111111| |
|2017-01-01|	002|	233333	|（由222222变成233333）|
|2017-01-01|	003	|333333| |
|2017-01-01|	004	|432432	|（由444444变成432432）|
|2017-01-02	|005	|555555	|（2017-01-02新增）|

可以发现每天会有`新增`和 `变化`的数据

## hive 中的实战
在现在的大数据场景下，大部分的公司都会选择以 Hdfs 和 Hive 为主的数据仓库架构。目前的 Hdfs 版本来讲，其文件系统中的文件是不能做改变的，也就是说 Hive 的表只能进行删除和添加操作，而不能进行 update。基于这个前提，我们来实现拉链表。

还是以上面的用户表为例，我们要实现用户的拉链表。在实现它之前，我们需要先确定一下我们有哪些数据源可以用。

* 我们需要一张 Ods 层的用户全量表。至少需要用它来`初始化`。
* 每日的用户更新表。

而且我们要确定拉链表的`时间粒度`，比如说拉链表`每天只取一个状态`，也就是说如果一天有 3 个状态变更，我们只取最后一个状态，这种天粒度的表其实已经能解决大部分的问题了。

**每日的用户更新表该怎么获取**，据笔者的经验，有3种方式拿到或者间接拿到每日的用户增量，因为它比较`重要`，所以详细说明：

* 我们可以监听 Mysql 库数据的变化，比如说用 Canal，最后合并每日的变化，获取到最后的一个状态。
* 假设我们每天都会获得一份切片数据，我们可以通过取两天切片数据的不同来作为每日更新表，这种情况下我们可以对所有的字段先进行 concat，再取 md5，这样就 ok 了。
* 流水表！有每日的变更流水表。

### Ods 层的 User表

现在我们来看一下我们 Ods 层的用户资料切片表的结构：
```sql
CREATE EXTERNAL TABLE ods.user (
  user_num STRING COMMENT '用户编号',
  mobile STRING COMMENT '手机号码',
  reg_date STRING COMMENT '注册日期'
COMMENT '用户资料表'
PARTITIONED BY (dt string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t' LINES TERMINATED BY '\n'
STORED AS ORC
LOCATION '/ods/user';
)
```

### Ods 层的 User_update 表

然后我们还需要一张用户每日更新表，前面已经分析过该如果得到这张表，现在我们假设它已经存在。
```sql
CREATE EXTERNAL TABLE ods.user_update (
  user_num STRING COMMENT '用户编号',
  mobile STRING COMMENT '手机号码',
  reg_date STRING COMMENT '注册日期'
COMMENT '每日用户资料更新表'
PARTITIONED BY (dt string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t' LINES TERMINATED BY '\n'
STORED AS ORC
LOCATION '/ods/user_update';
)
```
### 拉链表
现在我们创建一张拉链表：
```sql
CREATE EXTERNAL TABLE dws.user_his (
  user_num STRING COMMENT '用户编号',
  mobile STRING COMMENT '手机号码',
  reg_date STRING COMMENT '用户编号',
  t_start_date ,
  t_end_date
COMMENT '用户资料拉链表'
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t' LINES TERMINATED BY '\n'
STORED AS ORC
LOCATION '/dws/user_his';
)
```

### 实现 Sql 语句

然后初始化的 Sql 就不写了，其实就相当于是拿一天的 Ods 层用户表过来就行，我们写一下每日的更新语句。

现在我们假设我们已经已经初始化了 2017-01-01 的日期，然后需要更新 2017-01-02 那一天的数据，我们有了下面的 Sql。

然后把两个日期设置为变量就可以了。
```sql

INSERT OVERWRITE TABLE dws.user_his
SELECT * FROM
(
    SELECT A.user_num,
           A.mobile,
           A.reg_date,
           A.t_start_time,
           CASE
                WHEN A.t_end_time = '9999-12-31' AND B.user_num IS NOT NULL THEN '2017-01-01'
                ELSE A.t_end_time
           END AS t_end_time
    FROM dws.user_his AS A
    LEFT JOIN ods.user_update AS B
    ON A.user_num = B.user_num
UNION
    SELECT C.user_num,
           C.mobile,
           C.reg_date,
           '2017-01-02' AS t_start_time,
           '9999-12-31' AS t_end_time
    FROM ods.user_update AS C
) AS T
```

## 查询性能
拉链表当然也会遇到查询性能的问题，比如说我们存放了5年的拉链数据，那么这张表势必会比较大，当查询的时候性能就比较低了，个人认为两个思路来解决：
* `保留部分历史数据`，比如说我们一张表里面存放全量的拉链表数据，然后再对外暴露一张只提供近 3 个月数据的拉链表。
* 在设计拉链表的时候可以制定一些`数据的淘汰机制`。淘汰的数据不一定要删除，比如我们建立两张拉链表，一张拉链表中只保存最新的十条数据，其它的数据会存入一张历史拉链表中。

## 其它
* 使用拉链表的时候可以不加 t_end_date，即失效日期，但是加上之后，能优化很多查询。
* 可以加上当前行状态标识，能快速定位到当前状态。
* 在拉链表的设计中可以加一些内容，因为我们每天保存一个状态，如果我们在这个状态里面加一个字段，比如如当天修改次数，那么拉链表的作用就会更大。

## 参考链接
[拉链表是什么？](https://blog.csdn.net/MrZhangBaby/article/details/102689209)
[缓慢变化维](https://blog.csdn.net/MrZhangBaby/article/details/102690017)